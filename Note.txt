===========================  Theory  =================================

Jaman dulu ada Virtual Machine Manager / Hypervisor:
Contoh Product: VM Ware, Virtual Box

Virtualization digunakan untuk seperate deployment dan implementation supaya semua gak campur jadi satu,
tapi dengan cost setiap Virtual Machine harus ada OS masing2 yang membuat server jadi berat.

WSL (Windows Subsystem for Linux): Cara running Linux Kernel di windows
wsl --update

Kernel ada core dari OS, yang langsung bersentuhan dengan Hardware dan App.
Compatibility App semua dikarenakan kernelnya.

Di containerization, sangat memungkinkan:
Di server windows (sudah ada windows kernel) -> jalankan container windows
Di server windows -> jalankan linux kernel -> jalankan container linux
Di server linux (sudah ada linux kernel) -> jalankan container linux
Kernel dan container harus sama.

Docker Client:
	Docker Command dan Docker Desktop

Docker Server / Docker_Host / Docker_Daemon
	Docker Image / Package : paket aplikasi siap jalan (dependency, library, konfigurasi)
	Docker Container: Container ada images yang dirun. (Hasil instantiate dari image, bisa dalam keadaan diam juga)
		Bisa jadi 1 image di run beberapa kali sehingga menghasilkan lebih dari 1 containers.

Docker Registry (Image registry)

Kalau mau install docker desktop di Fedora, pastikan:
1. Install GNOME terminal
2. Sudah install KVM (Kernel Virtual machine)
3. Install Docker Engine
2. Sudah install GPG key management store

In real-world Docker/DevOps practice: the application and the database run in separate containers, built from different images.
Putting both in one container is technically possible, but considered bad design.

Docker follows this rule:
One container = one main responsibility (one process/service).

So typically:
One container â†’ your backend app (Spring Boot, Node, etc.)
One container â†’ database (MongoDB, MySQL, PostgreSQL, etc.)
They communicate over a virtual network.

Ketika membuat tag pada image:
image tidak benar-benar â€œdiduplikasiâ€
Docker tidak membuat image baru secara fisik.

Yang dibuat hanyalah:
ğŸ‘‰ pointer (label) baru ke image yang sama di disk.
Ibarat:
Satu file, tapi punya dua nama.

====================================Intro Image & Container==================================================

Nge-check docker image:
docker images
docker image ls

contoh narik images dari dockerhub:
docker pull mongo:latest

check daftar container yang ada di local (running):
docker container ls

check daftar container yang ada di local (semua):
docker container ls --all

Membuat mongo container dari existing images (ini nanti dikasih random name)
docker container create mongo:latest

Membuat mongo container dari existing images (ini diberi nama)
docker container create --name mongoserver1 mongo:latest

Contoh hasil container yang dibuat:
CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS    PORTS     NAMES
c5014123f081   mongo:latest   "docker-entrypoint.sâ€¦"   12 seconds ago   Created             mongoserver1

Note: kita tidak bisa menciptakan container dengan nama yang sudah dipakai, unique kaya variable

Contoh membuat 2 container dengan image yang sama:
CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS    PORTS     NAMES
6e313f9caeb3   mongo:latest   "docker-entrypoint.sâ€¦"   6 seconds ago   Created             mongoserver2
c5014123f081   mongo:latest   "docker-entrypoint.sâ€¦"   5 minutes ago   Created             mongoserver1

Contoh cara menjalankan existing container
docker container start mongoserver1

Hasil setelah dijalankan:
CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS         PORTS       NAMES
6e313f9caeb3   mongo:latest   "docker-entrypoint.sâ€¦"   2 minutes ago   Created                    mongoserver2
c5014123f081   mongo:latest   "docker-entrypoint.sâ€¦"   7 minutes ago   Up 5 seconds   27017/tcp   mongoserver1

Contoh cara menghentikan existing container
docker container stop mongoserver1

stop sekaligus
docker container stop mongoserver1 mongoserver2

Always prefer stop over kill.
kill = immediate force stop (can corrupt DB in rare cases)
stop = graceful shutdown

Untuk menghapus container:
docker container rm mongoserver2

Membuat docker container dengan settingan port:8080 yang bisa menggapinya di port 27017
docker container create --name mongoserver1 -p 8080:27017 mongo:latest

Image tidak bisa dihapus selama masih dipakai container.
Menghapus image
docker image rm mongo:latest

Membuka port yang sama ke public:
docker container create --name app1 -p 8080:8080 app-golang:1.0

======================================== Manual Image dan HUB =============================================

-Build docker imge dari dockerfile. Diakhir itu titik berdasarkan lokasi dockerfilenya yang berada di directory yang sama.
docker build --tag app-golang:1.0 .

Membuat tag dari existing image:
docker tag app-golang:1.0 bobywidjaja/app-golang:1.0
(Yang depan nama imagenya dan tagnya, yang belakang nama tag baru yang sudah sesuai dengan ketentuan docker hub)

docker push bobywidjaja/app-golang:1.0

======================================= ENVIRONMENT VARIABLE ==============================================

Menciptakan container dengan ENVIRONMENT variable
docker container create --name java-docker -p 8080:8080 -e NAME=Contoh java-docker:1.0
docker container create --name app2 -p 8083:8080 NAME=Contoh app-golang:1.0
(NAME=Contoh, adalah contoh environment variablenya)

Meng-inspect dan melihat ENV VARIABLE pada container yang sedang jalan
docker container inspect app1
[
	{
		"Config": {
			"Env": [
                "NAME=Contoh",
                "PATH=/go/bin:/usr/local/go/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
                "GOLANG_VERSION=1.25.6",
                "GOTOOLCHAIN=local",
                "GOPATH=/go"
			],
		}
	}
]

Check log, contohnya di Spring Boot terminal: (setelah di start pastinya)
docker container logs app1

Multiple environment variables
docker container create --name app3 -p 8084:8080 -e NAME=Docker -e APP=Java -e PASSWORD=rahasia app-golang:1.0

nama container akan menjadi pengganti IP Addressnya ketika melakukan implementasi
docker container create 
	--name java-docker -p 8080:8080
	-e NAME=Docker 
	-e MONGO_HOST=mongo -e MONGO_PORT=27017
	-e REDIS_HOST=redis -e REDIS_PORT=6379
	java-docker:1.0

jadi koneksi ke mongo adalah mongo:27017 dan ke redis adalah redis:6379

==================================== Network and Compose ==========================================

Tapi antar container belum bisa berkomunikasi satu sama lain, terkecuali kita kelompokan mereka ke dalam network yang sama.

Melihat ada commands apa saja pada network:
docker network --help

Melihat semua network
docker network ls

Membuat network baru
docker network create golang_network

Menambahkan container ke existing network;
docker network connect golang_network app1
docker network connect golang_network mongoserver1

Setelah itu, network bisa di check lewat inspect command, dan hasilnya:
"Networks": {
    "golang_network": {...}
}

Docker Compose adalah satu set konfigurasi untuk automasi container dan network.
Karena membuatnya satu-persatu akan repot, ada kemungkinan salah dan memakan waktu.

check docker compose version yang ada di system:
docker compose version

untuk check setiap perintah di docker compose:
docker compose
atau
docker compose --help

untuk me-running semua (Create dan start containers)
docker compose up
docker compose up -d (dettached mode)
	detatched mode akan menjalankan compose di belakang layar jadi kita gak perlu nungguin terminalnya.

Hati-hati menggunakan down, terutama dengan container database, karena akan menghapus total
docker compose down

Lebih aman stop containernya daripada down, karena tidak menghapus
docker compose stop

untuk memulai yang di stop bisa menggunakan
docker compose start

====================================== Volume ====================================================

Volum adalah solusi untuk membuat persistent data yang bersifat STATEFUL untuk database, sehingga
permanent data tidak akan hilang ketika container di stop atau di remove

Melihat semua perintah volume
docker volume --help

Membuat volume baru
docker volume create mongo_data

Set volume ke path dari databasenya
docker container create --name mongoserver1 -p 27017:27017 
	-v mongo_data:/data/db 
	mongo:latest

-v untuk volume dan :/data/db adalah lokasi pathnya, ini harus di selidiki di setiap DBMS

Volume totaly di manage sama Docker dan kita gak bisa lihat langsung isinya.
Tapi Bind Mounts bisa.

Contoh bind mounts:
docker container create --name mongoserver1 -p 27017:27017 
	-v /Users/Boby/Desktop/MyData:/data/db 
	mongo:latest

/Users/Boby/Desktop/MyData adalah absolute path HDD saya.
Posisinya persis menggantikan nama volume

===================================== Masuk Container =============================================

Kita bisa masuk ke dalam container untuk menjalankan sesuatu,
contoh saja dibawah ini menjalankan redis dari dalam container:
docker exec -t -i redisserver1 /bin/bash

Setelah itu kita bisa explore directorynya juga.

Berikut ini contoh menjalankan CLI executable file nya jika memang ada.
root@692129a4cf06:/usr/local/bin# ls
docker-entrypoint.sh  redis-benchmark  redis-check-aof	redis-check-rdb  redis-cli  redis-sentinel  redis-server
root@692129a4cf06:/usr/local/bin# type redis-cli
redis-cli is /usr/local/bin/redis-cli
root@692129a4cf06:/usr/local/bin# redis-cli
127.0.0.1:6379> get boby
(nil)
127.0.0.1:6379> set boby OhmBob
OK
127.0.0.1:6379> get boby
"OhmBob"
127.0.0.1:6379> exit
root@692129a4cf06:/usr/local/bin# 

===================================== Membersihkan sampah ==========================================

Melisting seluruh images, containers volumes dan cache yang terdapat di system:
docker system df

Menghapus semua container yang tidak dijalankan
docker container prune

Menghapus semua network yang tak terpakai
docker network prune

Menghapus seluruh volume yang tidak terpakai
docker volume prune

untuk menghapus dangling image:
docker image prune

(Dangling image artinya bukan image yang tidak ada containernya (unused image), dangling image artinya image
dia unused dan tidak memiliki nama dan tag. <none>:<none>)

untuk menghapus image yang unused atau tidak terpakai:
docker image prune -a

untuk menghapus banyak hal:
docker system prune

WARNING! This will remove:
  - all stopped containers
  - all networks not used by at least one container
  - all dangling images
  - unused build cache

docker system prune -a
WARNING! This will remove:
  - all stopped containers
  - all networks not used by at least one container
  - all images without at least one container associated to them
  - all build cache

docker system prune -a --volumes
WARNING! This will remove:
  - all stopped containers
  - all networks not used by at least one container
  - all anonymous volumes not used by at least one container
  - all images without at least one container associated to them
  - all build cache

(Note: Hati-hati penghapus volumes karena ada database di sana)

===================================== Linux Bash Command ===========================================

sudo dnf update

Fedoraâ€™s package manager (dnf) talks to online repositories and downloads:

âœ” list of available packages
âœ” their versions
âœ” dependencies
âœ” security updates
âœ” checksums & signatures

This information is called repository metadata.

It is basically:
a local database of what software exists and what versions are available.
Why it matters before installing software
Without fresh metadata:
your system may not see new packages
may install outdated versions
may fail dependency resolution
may miss security fixes
Updating metadata ensures:

âœ… you install the latest compatible software
âœ… dependency graph is correct
âœ… fewer errors
------------------------------------------------------------------------


============================================ Research List ===============================================

CNCF Cloud Native Computing Foundation ?

OCI Registry (Universal Distribution)
Package?

Docker Engine
Build -> Ship -> Run
Mirantis Container Runtime (MCR)
fault isolation (isolasi kegagalan)
Auto-restart (Kubernetes: jauh lebih canggih (self-healing))
Health check (Sistem tahu service sehat atau tidak)
Redundancy (replica) Jalankan beberapa container
Cari tau soal Backup, restore, migrate data volumes