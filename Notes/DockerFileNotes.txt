======================================== Manual Image dan HUB =============================================

-Build docker imge dari dockerfile. Diakhir itu titik berdasarkan lokasi dockerfilenya yang berada di directory yang sama.
docker build --tag app-golang:1.0 .
docker build --tag basilisk_sb:1.0 .

======================================== INSTRUCTION ======================================================

seluruh operasi di docker file disebut INSTRUCTION, dan isinya ARGUMENT. (Processed in order)
Macam-macam instruction:

1. FROM 
2. LABEL
3. ENV
4. WORKDIR
5. COPY / ADD
6. RUN
7. EXPOSE
8. USER
9. ENTRYPOINT
10. CMD

FLEW CAR EUEC

--------- FROM ----------

FROM: kasih tau ambil imagenya darimana. Nama image dan tag sebagai argumentnya
katanya akan secara otomatis juga terambil dari dockerhub seperti run. Remain to be tested
FROM [--platform=<platform>] <image>[:<tag>] [AS <name>]
FROM golang:1.25.6

--------- LABEL ----------

LABEL: Menambahkan metadata sesuka kita. Classic Key and Value Pair
LABEL <key>=<value> [<key>=<value>...]
LABEL maintainer="Boby"
LABEL version="1.0"
LABEL description="Backend API service"

Di check dengan docker inspect
"Config": {
  "Labels": {
    "maintainer": "Boby",
    "version": "1.0",
    "description": "Backend API service"
  }
}

--------- ENV ----------

ENV: instruksi yang digunakan untuk men-set environment variable.
ENV <key>=<value> [<key>=<value>...]

Satu per satu:
ENV MY_NAME="John Doe"
ENV MY_DOG=Rex\ The\ Dog
ENV MY_CAT=fluffy

atau sekaligus:
ENV MY_NAME="John Doe" MY_DOG=Rex\ The\ Dog \
    MY_CAT=fluffy

Seharusnya di real production, environment variable di dalam docker tidak boleh menyimpan password,
Env variable seperti db password harus dipakai hanya ketika dijalankan, atau di dalam docker compose atau di dalam secret manager.

docker run -e DB_PASSWORD=supersecret myapp

--------- WORKDIR ---------- 

WORKDIR: set current working directory dari directory di dalam container yang nanti dibuat dari image.
Apabila existing directory ditemukan, nah itu akan jadi working directory, tapi apabila tidak ditemukan, instruksi ini akan membuatkannya.

Dengan begini, perintah RUN, CMD, ENTRYPOINT, COPY, ADD tidak perlu menulis path lebih panjang karena current working directorynya
sudah di pindahkan.

WORKDIR /path/to/workdir

Tanpa WORKDIR:
COPY app.jar /app/app.jar
RUN java -jar /app/app.jar

Dengan WORKDIR:
WORKDIR /app
COPY app.jar .
RUN java -jar app.jar

WORKDIR bisa dipakai berkali-kali, itu artinya working directorynya di set atau di update beberapa kali.
Seperti global variable yang di set berkali-kali.


--------- COPY & ADD ----------

COPY: Mengcopy file dari directory kita ke directory hasil container, misalnya project file hasil build.
Best practice classic.

COPY [OPTIONS] <src> ... <dest>
COPY [OPTIONS] ["<src>", ... "<dest>"]
COPY main.go /app/main.go
COPY file1.txt file2.txt /usr/src/things/

ADD: Copy dengan Super Power.
Seperti copy tapi bisa extract beberapa compression dan bahkan download file dari URL.
Bahaya, unpredictable, hackable, please use COPY kalau gak necessary.

Note: Path tidak boleh menggunakan ../../

--------- RUN ----------

RUN: adalah instruksi pembuat dan peng-update image, misalnya di project kita punya begitu banyak dependency, di sini kita bisa tarik dan install setiap dependency nya dulu.
    RUN adalah murni command linux bash. Tapi tidak harus mengenai depency saja, bisa hal yang lain juga.
    Jadi setelah complete image lahir, image tersebut bisa langsung siap digunakan.

# Shell form:
RUN <command> ...
# Exec form:
RUN [ "<command>", ... ]

Contoh Shell Form:
RUN apt update
RUN npm install
RUN echo "Hello World"

Contoh Exec Form:
RUN ["apt", "update"]
RUN ["npm", "install"]
RUN ["echo", "Hello World"]

Untuk mengurangi ukuran image dan cache yang terlalu besar, satukan banyak command dibawah satu instruksi RUN, contoh:

Contoh Buruk: (3 buah run, build image juga lama)
RUN apt update
RUN apt install -y curl
RUN apt install -y git

Contoh Baik:
RUN apt update && apt install -y curl git
atau
RUN apt update \
 && apt install -y curl \
 && rm -rf /var/lib/apt/lists/*
 
RUN akan di-rebuild jika ada layer sebelumnya yang berubah, hal ini bisa menyebabkan bahaya peristiwa RUN berulang yang mengakibatkan lambat.

Jelek:
FROM node:20

COPY . .
RUN npm install
RUN npm run build

Bagus:
FROM node:20

COPY package.json package-lock.json ./ (Perintah ini ada cachenya untuk specific file)
RUN npm install (cuma diulang pada saat ada update package.json.)
COPY . . (Perintah .. tidak ada cachenya, rusak cachenya)
RUN npm run build (diulang terus kalau copy apa saja)

--------- EXPOSE ----------

EXPOSE: instruksi yang mengatur port number ketika menjalankan container. Ini seharusnya jadi container port, bukan host port, karena
hostport nanti diberikan di opsi perintah create container.

EXPOSE <port> [<port>/<protocol>...]

EXPOSE 8080
EXPOSE 8080/tcp

Note: docker tidak kenal beberapa protocol aplikasi seperti http, smtp, ftp, dan lain-lain

Note: tujuan dari expose hanya dokumentasi, dia tidak akan membuka port tersebut ke host. untuk membukanya tetap harus menggunakan -p.
Tetapi kita bisa menggunakan dokumentasi EXPOSE untuk digabung dengan -p, yaitu gunakan huruf besar -P

--------- ENTRYPOINT ----------

ENTRYPOINT: dia mirip sebenarnya seperti CMD, tetapi dia adalah perintah tetap yang tidak bisa di override.
lain dengan CMD yang total perintah dan argumentnya bisa di override.

FROM ubuntu
CMD ["echo", "Hello"]
docker run image >> Hello
docker run image echo World >> World

FROM ubuntu
ENTRYPOINT ["echo", "Hello"]
docker run image >> Hello
docker run image echo World >> Hello World

Best Practice:
FROM ubuntu
ENTRYPOINT ["echo"]
CMD ["Hello"]

CMD menjadi default parameter

--------- CMD ----------

CMD: instruksi ini adalah default command yang dijalankan ketika container sudah di start.
Terkecuali ada specific command yang dijalankan yang bisa override default command ini.
Bagian perintah dari CMD bisa di override.

Ada 3 bentuk argument pada CMD:
CMD command param1 param2 (shell form)
CMD ["executable","param1","param2"] (exec form)
CMD ["param1","param2"] (exec form sebagai parameter default dari ENTRYPOINT instruction)

CMD java -jar /app/demo-docker.jar
CMD ["java", "-jar", "/app/demo-docker.jar"]

--------- USER ----------

USER: menentukan user dan group yang dipakai saat container dijalankan
Ini kaitannya nanti dengan security dan authorization.
Default usernya adalah root bila tidak ditulis:

Kalau kamu tidak menulis USER, maka:
Proses di dalam container = root
UID = 0
Sama seperti sudo di Linux

USER appuser
USER UID 
USER appuser:appgroup

USER Boby
USER 10001

--------- VOLUME ----------

VOLUME

--------- ARG ----------

ARG 

--------- ONBUILD ----------

ONBUILD

=========================================

HEALTHCHECK

SHELL

STOPSIGNAL

====================== DEPRECATED ==========================

MAINTAINER